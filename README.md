# Транслятор + Мини-IDE

Этот проект — учебная реализация простого транслятора и мини-IDE.  
Он включает в себя полный цикл работы с небольшим языком программирования:

- **Лексический анализатор (Lexer)** — разбивает исходный код на токены.  
- **Синтаксический анализатор (LL(1) Parser)** — проводит лексический анализ и строит абстрактное синтаксическое дерево (AST).  
- **Генератор кода** — переводит AST в ассемблер (NASM, Linux x86-64).  
- **Мини-IDE** — простое настольное приложение, где можно писать код, подсвечивать синтаксис, транслировать в ассемблер и запускать программу.

## Возможности

- Подсветка синтаксиса.
- Отображение AST в виде дерева.
- Генерация ассемблерного кода из программы.
- Просмотр итогового кода через `ShowAssembly`.
- Запуск сгенерированного кода через `Run` (использует сервер с NASM внутри Docker).

## Как работает

1. Вы пишете программу на нашем учебном языке.  
2. Lexer превращает текст в токены.  
3. Parser строит дерево разбора.  
4. Генератор формирует ассемблерный код.  
5. Через IDE можно:
   - работать с файлами и кодом,
   - посмотреть сгенерированный ASM,
   - запустить код (через удалённый сервер, если вы на macOS ARM и не можете собрать локально).


## Интеграция с сервером выполнения

Для выполнения сгенерированного ассемблера можно использовать наш [мини-сервер](https://github.com/ghimik/ASMServer) в Docker.
IDE отправляет код на сервер по REST API и получает результат выполнения.

# Транслятор + Мини-IDE

Этот проект — учебная реализация простого транслятора и мини-IDE.  
Он включает в себя полный цикл работы с небольшим языком программирования:

- **Лексический анализатор (Lexer)** — разбивает исходный код на токены.  
- **Синтаксический анализатор (LL(1) Parser)** — строит абстрактное синтаксическое дерево (AST).  
- **Генератор кода** — переводит AST в ассемблер (NASM, Linux x86-64).  
- **Мини-IDE** — простое настольное приложение, где можно писать код, подсвечивать синтаксис, транслировать в ассемблер и запускать программу.


## Описание учебного языка

Учебный язык очень маленький, но в нём есть всё необходимое для примеров:

### Типы данных
- `Integer` — целое число.  
- `Boolean` — логическое значение (`true` или `false`).

### Объявление переменных
Переменные объявляются в начале программы:

```
Integer x, y, z
Boolean flag
```

### Структура программы
Программа состоит из двух частей:
1. Объявления переменных.
2. Блок вычислений между `Begin ... End`, после которого идёт обязательный оператор `Print`.

Пример каркаса:
```
Integer x, y
Begin
x := 5;
y := x + 1;
End
Print y
```

### Присваивания и выражения
- Присваивание: `x := 5;`  
- Арифметика: `+ - * /`  
- Скобки поддерживаются: `(x + 2) * y`  
- Логические выражения:
  - Сравнения: `<`, `>`, `<=`, `>=`, `==`, `!=`
  - Логика: `NOT`, `AND`, `OR`  

### Управляющие конструкции
- **IF / ELSE**:
```
IF flag THEN
x := x + 1;
ELSE
x := x - 1;
ENDIF
```

- **WHILE**:
```
WHILE i < 5 DO
sum := sum + i;
i := i + 1;
ENDWHILE
```

- **CASE**:
```
CASE a OF
1: b := 10;
2: b := 20;
3: b := 30;
ENDCASE
```

### Печать
В конце программы обязательно должен быть оператор:
```
Print <переменная>
```
---

## Примеры программ

### 1. Арифметика и печать
```
Integer x, y, z
Begin
x := 5;
y := x + 3;
z := y * 2;
End
Print z
```

### 2. CASE
```
Integer a, b
Begin
a := 2;
CASE a OF
1: b := 10;
2: b := 20;
3: b := 30;
ENDCASE
End
Print b
```

### 3. IF
```
Integer x
Boolean flag
Begin
x := 10;
flag := true;
IF flag THEN
x := x + 1;
ELSE
x := x - 1;
ENDIF
End
Print x
```

### 4. WHILE
```
Integer i, sum
Begin
i := 0;
sum := 0;
WHILE i < 5 DO
sum := sum + i;
i := i + 1;
ENDWHILE
End
Print sum
```


## Зачем это нужно?

Это не «боевой» инструмент, а учебная и экспериментальная платформа.
Она позволяет разобраться:

* как устроены лексеры и парсеры,
* как из дерева разбора получить машинный код,
* как IDE взаимодействует с бэкендом для запуска программ.

Полезно для студентов, энтузиастов и тех, кто хочет почувствовать, как работает компилятор изнутри.

